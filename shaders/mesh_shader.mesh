#version 450
#extension GL_EXT_mesh_shader : require
#extension GL_EXT_scalar_block_layout : require
#extension GL_EXT_buffer_reference : require

struct Tri {
	uvec3 indices;
};

struct Meshlet {
	vec3 pos[32];
	Tri tri_indices[32];
	vec3 prim_colors[32];
	int prim_count;
	int vert_count;
};

layout(scalar, buffer_reference) buffer MeshBuffer {
	Meshlet[] meshlets;
};

layout(scalar, push_constant) uniform T {
	mat4 matrix;
    ivec3 chunk_position;
    float time;
    MeshBuffer mesh_buffer;
	uint num_verts;
} push_constants;

layout(local_size_x = 32, local_size_y = 1, local_size_z = 1) in;
layout(triangles, max_vertices = 32, max_primitives = 32) out;

// layout(location = 0) out VertexOutput
// {
// 	vec4 color;
// } vertexOutput[];

const vec4[6] colors = {
	vec4(0.0, 1.0, 0.0, 1.0),	// top
	vec4(1.0, 0.0, 0.0, 1.0),	// north
	vec4(0.0, 0.0, 1.0, 1.0),	// west
	vec4(1.0, 0.0, 1.0, 1.0), 	// east
	vec4(0.0, 1.0, 1.0, 1.0), 	// south
	vec4(1.0, 1.0, 0.0, 1.0) 	// bottom
};

layout(location = 0) perprimitiveEXT out PrimitiveOutput {
	vec4 color;
} primitiveOutput[];

struct Task {
	uint offset;
	uint numWorkgroups;
};

taskPayloadSharedEXT Task payload;

void main() {
	int verticesOut = push_constants.mesh_buffer.meshlets[gl_WorkGroupID.x].vert_count;
	int primitivesOut = push_constants.mesh_buffer.meshlets[gl_WorkGroupID.x].prim_count;
	SetMeshOutputsEXT(32, 32);

	mat4 mvp = push_constants.matrix;

	Meshlet meshlet = push_constants.mesh_buffer.meshlets[gl_WorkGroupID.x];
	vec3 chunk_offset = vec3(push_constants.chunk_position * 16);
	Tri tri = meshlet.tri_indices[gl_LocalInvocationID.x];
	vec3 color = meshlet.prim_colors[gl_LocalInvocationID.x] / vec3(255.0);

	gl_MeshVerticesEXT[gl_LocalInvocationID.x].gl_Position = mvp * vec4(meshlet.pos[gl_LocalInvocationID.x] + chunk_offset, 1);

	if(tri.indices.x != tri.indices.y) {
		gl_PrimitiveTriangleIndicesEXT[gl_LocalInvocationID.x] = tri.indices;
	    primitiveOutput[gl_LocalInvocationID.x].color = vec4(color, 1.0);
	}

// 	uint sharedData = payload.offset * gl_NumWorkGroups.x;

//     bool is_even = gl_LocalInvocationID.x % 2 == 0;
// 	uint triId = gl_LocalInvocationID.x;
// 	uint faceId = triId / 2;
// 	uint vtx_offset = gl_WorkGroupID.x * 4;

// 	vec3 color = push_constants.mesh_buffer.vertices[vtx_offset].color / vec3(255.0);

// 	mat4 mvp = push_constants.matrix;

// 	if (is_even) {
// 		vec3 vertex0 = push_constants.mesh_buffer.vertices[vtx_offset].pos + push_constants.chunk_position * 16;
// 		vec3 vertex1 = push_constants.mesh_buffer.vertices[vtx_offset + 1].pos + push_constants.chunk_position * 16;
// 		gl_MeshVerticesEXT[0].gl_Position = mvp * vec4(vertex0, 1);
// 		gl_MeshVerticesEXT[1].gl_Position = mvp * vec4(vertex1, 1);

// 	} else {
// 		vec3 vertex0 = push_constants.mesh_buffer.vertices[vtx_offset + 2].pos + push_constants.chunk_position * 16;
// 		vec3 vertex1 = push_constants.mesh_buffer.vertices[vtx_offset + 3].pos + push_constants.chunk_position * 16;
// 		gl_MeshVerticesEXT[2].gl_Position = mvp * vec4(vertex0, 1);
// 		gl_MeshVerticesEXT[3].gl_Position = mvp * vec4(vertex1, 1);
// 	}
// 	if (is_even) {
//     	gl_PrimitiveTriangleIndicesEXT[triId] = uvec3(0, 1, 2);
// 	    primitiveOutput[triId].color = vec4(color, 1.0);
//     } else {
//     	gl_PrimitiveTriangleIndicesEXT[triId] = uvec3(0, 2, 3);
// 	    primitiveOutput[triId].color = vec4(color, 1.0);
//     }
}
